openapi: 3.0.2

servers:
  - url: 'https://api.solvice.io/'
    description: Production cluster

info:
  version: "1.0.1"
  title: OnShift API
  x-logo:
    url: 'logo.png'
    altText: OnShift API
  description: |

    Welcome to the Solvice API! You can use our API to access Solvice API endpoints,
    which can get information on your solved jobs,
    their statuses and of course post new solve jobs.

    # Workforce Optimisation


    OnShift is a solver engine for solving workforce optimisation problems through the Solvice Optimisation API Platform.

    Creating an optimal roster for a team of employees based on forecasted demand and taking into account extensive labor agreement rules & other constraints.


    The Solvice Workforce Optimisation API consists of the following RESTful web services:
     * [Shift Planning API](#section/Shift-scheduling)
     * [Fill Planning API](#section/Fill-scheduling)
     * [Task Sequencing API](#section/Task-sequencing)
     * [Shift Creation API](#section/Shift-creation)

    ### Getting started
     1. To use one of these APIs, you require an API key. Sign up [here](https://www.solvice.io/onshift/register) to get one.
     2. Read the documentation of the desired API below.
     3. Start using the API.

    ### Overview

    > Test our API in just one command

     ```shell
     curl https://demo:demo@api.solvice.io/demo/fill | \
     curl https://demo:demo@api.solvice.io/v1/solve  \
          -X POST -H "Content-Type: application/json" -d @-
     ```
     >You can copy and paste the above in your terminal for a working example. The example uses a randomly generated FILL problem.



     The Solvice API is super simple! Basically, it holds one [/solve](#solve-endpoint)  endpoint for sending an asynchronous solve request to for a certain optimization problem and it holds one [/jobs/:job_id/solution](#jobs-endpoint)  endpoint for retrieving the solved job asynchronous. That's it!
     The only thing you have to manage is the actual payload for the solve request.



    The OnShift API is as simple as it gets. There are only several important endpoints:

     1. Solving an OnShift optimisation problem is as simple as an POST to our `/solve` endpoint.
     2. The Job `id` is returned.
     3. Check for the status of that job wether it is solved yes with the GET `/jobs/<id>/status` endpoint.
     4. If so, then fetch the solution with a simple GET on `/jobs/<id>/solution`

    Thats's it! Could not be easier.

    To use our Workforce Optimisation API commercially, you can subscribe to a paid plan [here](https://www.solvice.io/onshift/api#pricing).

    ### Problems or Questions?
    If you have problems or questions, we offer you the following options:
     * [FAQ](https://www.solvice.io/faq)
     * [Open ticket]()
     * [Contact us](https://www.solvice.io/contact)

    <!---To get informed about the newest features and development follow us at [twitter](https://twitter.com/solvice_io/). Furthermore you can watch [this git repository](https://github.com/solvice/workforce-api-docs) of this documentation, sign up at our [dashboard](https://dashboard.solvice.io/).--->



    ## Explore our APIs


    #### Insomnia
    To explore our APIs with Insomnia, follow these steps:
    [![Run in Insomnia}](https://insomnia.rest/images/run.svg)](https://insomnia.rest/run/?label=OnShift%20API&uri=https%3A%2F%2Fdocs2.solvice.io%2Fonshift%2Finsomnia_fill.json)




tags:
  - name: Workforce Optimisation
    description: |

      OnShift can solve different workforce optimisation problems.


      ## Shift scheduling
      Creating an optimal roster for a team of employees based on forecasted demand and taking into account extensive labor agreement rules & constraints.
      - Based on last weeks sales, last planning, predicted weather, revenue and reservations, a clear demand can be generated used as base occupation per skill, per location, per time block.
      - Collective Work Agreements are numerous and complex. Our optimisation already takes into account hundreds of specific employee constraints. Not enough? Simply create your own work rules.
      - Not only automagically generate a plan in seconds, but define what is important in the optimisation. Is financial wage cost minimisation more important than fairness? It's just a parameter. Our advanced mathematical solver engine can handle any request.


      ## Fill scheduling


      ### Input
      Filling in pre-defined shifts with employees according to contractual agreements that enforce fair and cost efficient rosters.
      The input requires you to make up:

       - contract definitions
       - open shifts
       - available employees

      #### Contract
      A contract definition consists of a multitude of labour restricting constraints such as the maximum number of consecutive working days,
      the maximum number of shifts per day, number of resting days, etc...

      ```json
        {
          "name": "FULL",
          "max": "PT38H",
           "min": "PT5H",
           "maxConsecutiveWorkDays": 5,
           "maxShiftsDay": 2,
           "minRestBetweenShiftsSameDay": 30,
           "maxWorkingDays": 6,
           "latestShiftStart": "10:00:00",
           "earliestShiftStart": "02:00:00"
        }
      ```

      #### Shifts

      The shifts represent the demand. These shifts need to be filled in with employees.
      A shift in its simplest form can be defined by a shift start time (`from`) and an end time (`to`).
      Shifts are uniquely identified by a `name` and require a specific `skill`.
      You can define the number of employees that need to be assigned to this shift with `value`.

      ```json
      {
         "name": "Shift 1",
         "from": "2020-06-26T08:00:00",
         "to": "2020-06-26T17:00:00",
         "skill": "skill1",
         "value": 3
       }
      ```

      #### Employee

      Define the resources or employees with whom you want to fill up the shifts.

      ```json
      {
        "name": "John Dory",
        "contract": "FULL",
        "availability": [
          {
            "from": "2020-06-26T08:00:00",
            "to": "2020-06-30T08:00:00"
          }
        ],
        "skills": [
            "waiter",
            "bar"
        ],
        "hourlyPay": 15.5
      }
      ```
      ### Output

      Simply fetch the solution in the `jobs/:id/solution` endpoint and receive the shift assignments.
      For every shift defined by its `name` we will assign the best `employee`.

      ```json
      [
        {
          "name": "Morning Shift 1",
          "from": "2020-06-26T08:00:00",
          "to": "2020-06-30T08:00:00",
          "employee": "John Dory",
          "skills": [
              "waiter",
              "bar"
          ]
        }
      ]
      ```


      ### Constraints

      We take into account many constraints. Let us know if there are any constraints that you think are missing.

      | Code             | Level  | Description                               |
      |------------------|--------|--------------------------------------------|
      | Maximum Working Days | HARD | An employee should not work more than `contract.maxWorkingDays` days in the planning horizon.  |
      | Maximum Hours | HARD | An employee should not work more than `contract.max` hours in the planning horizon. |
      | Minimum Hours | HARD | An employee should not work less than `contract.min` hours in the planning horizon. Please ensure minimum feasibility over the whole workforce.  |
      | Earliest Shift Start  | HARD| Earliest time `contract.earliestShiftStart` in a day when an employee is allowed to work |
      | Latest Shift Start  | HARD| Earliest time `contract.latestShiftStart` in a day when an employee is allowed to start work |
      | Latest Shift End  | HARD| Latest time `contract.latestShiftEnd` in a day when an employee is allowed to end work  |
      | Maximum Shift Length | HARD | Maximum time `contract.maxShiftLength` that an employee is allowed to work |
      | DayOfWeek Working | HARD | Restricts employee availability based on days in the week that  |
      | Minimum Shift Length | HARD | Minimum time `contract.maxShiftLength` that an employee is allowed to work |
      | Maximum Shifts On Same Day  | HARD| Maximum number of shifts that an employee is allowed to work |
      | Minimum Rest On Same Day | HARD | Minimum resting period between two shifts on the same day |
      | Employee Availability | HARD | Date-time range of employee's availability |
      | Travel Time  | SOFT | Travel from home to shift location |
      | Priority | SOFT | Shift Priorities |
      | Locked Assignment | HARD | Take into account assignments that are fixed during the solve |
      | Maximum Consecutive Working Days | HARD | No more than `contract.maxConsecutiveWorkDays` consecutive shifts. |
      | Minimum Rest | HARD | Minimum resting between two shifts (irrespective of shifts) |
      | Shift Employee Preference  | SOFT| A preference for a certain shift assignment for an employee |
      | Financial Costs | SOFT | Some shifts incurr a higher cost when they are assigned to (opposite of priority) |
      | Wage Costs per Employee  | SOFT| Hourly wage cost per employee influences choice of employee |
      | Unassigned Employee| SOFT | Minimise the number of unassigned employees |
      | No Concurrent Assignments| HARD | An employee cannot have two assignments on the same time. (This should never happen)  |
      | Skill Requirement for shifts | HARD | Multiple shifts can have a shared requirement for a skill |
      | Employee Skill Match | HARD| Assign employees to match according to their skills and the required skills for a shift |
      | Employee Skill Match Soft | SOFT | Assign employees to match according to their skills and the required skills for a shift (soft rule) |
      | Employee Critical Skill Match | SOFT | Prefer assigning critical shifts first  |


      ## Task sequencing
      Sequencing tasks in time according to the available resources: A task sequencing problem can be solved for work defined according to two hierarchies: *orders* and *tasks*
      If only orders are provided, they will be scheduled as if they are the lowest level detail that needs to be handled by the sequencing model. If however, orders are defined that contain tasks,
      these tasks are considered the lowest level detail of work that needs to be sequenced. The order level is then only used to incorporate priorities.


      ### Model

      #### Order

      An Order is an executable piece of work that can take a pre-determined amount of time, and that needs to be handled with a certain priority. It can contain multiple tasks.
      If tasks are provided, they are sequenced rather than the order itself. An order can have an availability and should have a resourceRequirement.


      #### Task

      A task is the lowest-level detail for work that needs to be scheduled that can be provided in the model. If provided, it is always defined under the higher hierarchy of an order. Futher, we define tasks using
      a duration (pre-determined amount of time to finish the task), a resourceRequirement and (optionally) an availability.

      #### ResourceRequirement

      For the work that is incorporated in the model (from either orders or tasks), a resource requirement can be defined. A resource requirement can be specified using three different constructs:
        - a combination of the name of the *capacitated* resource type and how many of these resources are required.
        - a combination of the name of the *plannable* resource type and the name of the specific resource that is required.
        - a combination of the name of the *plannable* resource type and an object that incorporates how many resources and what (additional) skills they require.

      ```json
            {
              "hammer": 2,
              "location": "location0"
              "operator": {
                "value" : 2,
                "skill" : ["electrician", "heavy tool"]
              }
            }
      ```

      #### Resource

       There are 2 types of Resources:

       - a *Plannable* Resource: demands that a resource is explicitly assigned to a task.
       - a *Capacitated* Resource: only requires available capacity of a resource. Specific assignment is not necessary.

      For example, take the assignment problem of a task "hammer a nail" that requires a technician and a hammer to execute that task.
      Usually, we don't need to know that for task "hammer a nail", you need a specific hammer with serial number SNxxx.
      You just need to know that there are ample hammers availabe for all tasks that require a hammer to be performed at the same time.  E.g. there are 4 hammers available and you will take 1.
      For a technician however, it might be required that the schedule points out who will execute that task.
      Will it be John, Alex or Lee?
      Therfore, a hammer can be considered a Capacitated Resource, while a technician is a Plannable Resource in this example.

      Structure of a Capacitated Resource:
      ```json
      {
        "type": "capacitated",
        "name": "hammer",
        "supply": 4,
        "availability": [ {
          "from": "2021-02-06T09:00:00",
          "to": "2021-02-06T18:00:00"
        }]
      }
      ```

      Structure of a Plannable Resource:
      ```json
      {
        "type": "plannable",
        "name": "technician",
        "supply": [
          {
            "name": "John",
            "skill": ["a","b"],
            "availability": [ {
              "from": "2021-02-06T09:00:00",
              "to": "2021-02-06T18:00:00"
            }]
          }
        ]
      }
      ```

      ### Constraints


      | Code             | Description                               |
      |------------------|-------------------------------------------|
      | Resource Availability | A task should not be planned to a resource outside its availability  |
      | Resource Capacity | A resource should not assigned at the same time to more than one task. |
      | Order Priority | The priority of the orders that are assigned is maximized.  |


      ## Shift Creation

      Assigning an amount of people to certain shifts according to demand and resource constraints.

      ### Input
      The input requires two main things.

      - shift patterns: which shifts can the solver choose from
      - demands: how many people are needed and at what time?

      The demands can be provided in two different ways. Depending on which kind of demands are used, the solver will run in either `fixed` or `flexible` mode.

      #### Shift Pattern
      A `Shift Pattern` is the central unit modified by the solver. The main goal for the solver is to find the optimal nubmer of people to assign to each shift.
      Here is an example of a shift from Monday to Friday from 9AM to 5PM. The solver will choose somewhere between 0 and 10 people to assign to this shift.

      ```json
      {
        "name": "MON:9-5",
        "min": 0,
        "max": 10,
        "skill": "technician",
        "definition": [
          {
            "from": "2021-10-04T09:00",
            "to": "2021-10-04T17:00"
          },
          {
            "from": "2021-10-05T13:00",
            "to": "2021-10-05T17:00"
          },
          [ ... ]
          {
            "day": "FRIDAY",
            "from": "2021-10-08T13:00",
            "to": "2021-10-08T17:00"
          }
        ]
      }
      ```

      #### Demand

      Two types of demand are possible, an example of each type will be given here. The demands used in `fixed` mode are the most intuitive. During this mode, the
      value given with each demand interval denotes the expected number of people between this interval.
      Here is an example where 5 technicians are needed between 9AM and 5PM on Moday Oktober 4th.

      ```json
      {
        "from": "2021-10-04T09:00,
        "to": "2021-10-04T17:00",
        "skill": "technician",
        "demand": 5
      }
      ```

      For `flexible` mode, the demands look slightly different. Instead of the `demand` atribute, a `min` and `max` need to be provided. These tell the solver that at the
      start of this interval, already `min` number of minutes of work needs to have been done. By end of this interval, a total of `max` amount of minutes may be done.
      `min` can be seen as work that has to be completed and `max` can be seen as the total amount of work that is available.

      ```json
      {
        "from": "2021-10-04T09:00,
        "to": "2021-10-04T17:00",
        "skill": "technician",
        "min": 60,
        "max": 180,
      }
      ```

      Fixed and Flexible demands cannot be mixed in the same creation request.

      #### Resources

      Resources can be used to further constrain the problem. A `resource` is a named unit with a finite supply that can be used by shifts. Available resources are listed in the model
      in the follwoing way.

      ```json
      {
        "resourceAvailabilities": [
          {"resourceName": "hammer", "max": 10},
          {"resourceName": "screwdriver", "max": 5}
        ]
      }
      ```

      This is how a shift can be configured to use one or more resources. This build on the first example of a Shift Pattern.

      ```json
      {
        "name": "MON:9-5",
        "min": 0,
        "max": 10,
        "skill": "technician",
        "resourceRequirements": [
          {"resourceName": "hammer", "value": 1},
          {"resourceName": "screwdriver", "value": 2}
        ],
        "definition": [
          {
            "from": "2021-10-04T09:00",
            "to": "2021-10-04T17:00"
          },
          {
            "from": "2021-10-05T13:00",
            "to": "2021-10-05T17:00"
          },
          [ ... ]
          {
            "day": "FRIDAY",
            "from": "2021-10-08T13:00",
            "to": "2021-10-08T17:00"
          }
        ]
      }
      ```

      ### Output

      The output of the creation solver is a list of shifts of the following form. The `pattern` value refers to the unique name given to each shift on the input side.

      ```json
      [
        {"pattern": "9-5, MON-FRI: technician", "skill": "technician", "value": 3},
        {"pattern": "9-5, MON-FRI: mechanic", "skill": "mechanic", "value": 2}
      ]
      ```

      ### Constraints

      The following constraints are used when solving the problem. Some are only valid in either `fixed` or `flexible` mode.

      | Code             | Level  | Description                               |
      |------------------|--------|--------------------------------------------|
      |Total Demand | HARD | The total required demand must be met. Only applicable in `fixed mode`. |
      |Resource Availability | HARD | For every resource, the solver tracks how many are being used at each point in time. It minimises the amount of over-usage that occurs for each resource. |
      |Under Demand | MEDIUM | For every demand interval, the supply that is less than the demand must be minimised. Only applicable in `fixed` mode. |
      |Over Demand | MEDIUM | For every demand interval, the supply that is more than the demand must be minimised. Only applicable in `fixed` mode. |
      |Under Demand Cumulative | MEDIUM | For every demand interval, the total amount of work done needs to be more than the minimum required amount of work that has been done. Only applicable in `flexible` mode. |
      |Over Demand Cumulative | MEDIUM | When staffing so many people that the total amount of work done exceeds the amount of work available, some people are doing nothing during their shift. Minimise this time that is being wasted. Only applicable in `flexible` mode. |
      |As Late As Possible | SOFT | Execute the required amount of work as late as possible. This also means that the solver will try to execute a minimum amount of work. Only applicable in `flexible` mode. |
      |Costs | SOFT | Cost based minimisation of the shifts. |
      |Preference | SOFT | Preference based maximisation of the shifts. |



  - name: Jobs
    description: The Jobs endpoint allows to retrieve information of a posted request, its status, the score or even detailed statistics.


  - name: Scheduling
    description: |
      It is possible to generate the planning by doing a `solve` or either `evaluate` a current solution by doing a `evaluate`.
      Post a new solve request to the Workforce Optimisation Engine.

      The optimisation engine can accept different problems:
       - CREATE: `CreateRequest`
       - FILL: `ShiftFillRequest`
       - TASK: `TaskRequest`

  - name: Solution
    description: Retrieve the optimal solution to the problem.
  - name: FAQ
    description: |




security:
  - ApiKey: []

paths:
  /solve:
    post:
      tags:
        - Scheduling
      summary: Solve problem
      operationId: solve
      parameters:
        - in: query
          name: seconds
          example: 20
          schema:
            type: integer
          description: The number of seconds you give the solver to optimise the problem. By default, the solver decides.

      description: |
        Endpoint for solving shift optimisation problem.
        There are multiple possible problems:
         1. Shift Scheduling: `SHIFT` solver to send a `ShiftRequest`
         2. Shift Creation: `CREATE` solver to send a `CreationRequest`
         3. Shift Filling: `FILL` solver to send a `ShiftFillRequest`
         4. Task Assigning: `TASK` solver to send a `TaskRequest`
      requestBody:
        description: |
          Any of the Shift Filling, Shift Creation or Task Assignment requests.
        required: true
        content:
          application/json:
            examples:
              FILL:
                summary: Shift Filling
                value:
                  $ref: ./onshift/examples/fill.json
              CREATE:
                summary: Shift Creation
                value:
                  $ref: ./onshift/examples/creation.json
              TASK:
                summary: Task Assignment
                value:
                  $ref: ./onshift/examples/task.json
            schema:
              oneOf:
                - $ref: '#/components/schemas/ShiftRequest'
                - $ref: '#/components/schemas/CreationRequest'
                - $ref: '#/components/schemas/ShiftFillRequest'
                - $ref: '#/components/schemas/TaskRequest'
              discriminator:
                propertyName: solver
                mapping:
                  SHIFT: '#/components/schemas/ShiftRequest'
                  FILL: '#/components/schemas/ShiftFillRequest'
                  CREATE: '#/components/schemas/CreationRequest'
                  TASK: '#/components/schemas/TaskRequest'


      responses:
        '200':
          description: solve job accepted to queue
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatusJob'
        '400':
          $ref: '#/components/responses/WrongFormat'
        '401':
          $ref: '#/components/responses/Unauthorized'

  /evaluate:
    post:
      tags:
        - Scheduling
      summary: Evaluate problem
      operationId: evaluate
      description: Endpoint for evaluating optimisation problem.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              anyOf:
                - $ref: '#/components/schemas/ShiftRequest'
                - $ref: '#/components/schemas/CapacityRequest'
                - $ref: '#/components/schemas/ShiftFillRequest'
                - $ref: '#/components/schemas/TaskRequest'
      responses:
        '200':
          description: Job valid
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatusJob'
        '400':
          $ref: '#/components/responses/WrongFormat'
        '401':
          $ref: '#/components/responses/Unauthorized'

  '/jobs/{jobId}':
    get:
      tags:
        - Jobs
      summary: Job
      operationId: getJob
      description: When posting a new solve request, this job can be checked again under this endpoint.
        In fact, it should be the entire request posted as-is.
      parameters:
        - in: path
          name: jobId
          required: true
          description: The job ID.
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: return a job
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatusJob'
        '404':
          description: 'Job not found'

  /v1/stats/{jobId}:
    get:
      tags:
        - Jobs
      summary: Statistics
      operationId: getStats
      parameters:
        - in: path
          name: jobId
          required: true
          description: The job ID.
          schema:
            type: string
            format: uuid
      description: |
        Returns the information on why a job has been solved the way it's been.
        Information includes specific unresolved objects. Want to know how it is optimised?
        This endpoint lets you know what rules have been overruled.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Stats'
        '404':
          description: 'Job not found'

  /jobs/{jobId}/status:
    get:
      tags:
        - Jobs
      parameters:
        - name: jobId
          in: path
          description: Job ID
          required: true
          schema:
            type: string
            format: uuid
      summary: Get a status
      operationId: getStatus
      responses:
        '200':
          description: get job status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatusJob'
        '400':
          description: bad input parameter

  /jobs/{jobId}/solution:
    get:
      tags:
        - Solution
      parameters:
        - name: jobId
          in: path
          description: Job ID
          required: true
          schema:
            type: string
            format: uuid
      summary: Get a solution
      operationId: getSolution
      responses:
        '200':
          description: Valid Job
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/ShiftSolution'
                  - $ref: '#/components/schemas/FillSolution'
                  - $ref: '#/components/schemas/CreateSolution'
                  - $ref: '#/components/schemas/CapacitySolution'
                  - $ref: '#/components/schemas/TaskSolution'
                discriminator:
                  propertyName: solver
                  mapping:
                    SHIFT: '#/components/schemas/ShiftSolution'
                    FILL: '#/components/schemas/FillSolution'
                    CREATE: '#/components/schemas/CreateSolution'
                    TASK: '#/components/schemas/TaskSolution'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'


components:
  schemas:
    ShiftRequest:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolveJob'
        - type: object
          required:
            - demand
            - employees
            - statutes
          properties:
            demand:
              type: array
              description: Demand blocks for which a certain number of employees by a certain skill and on a certain location are required.
              items:
                $ref: '#/components/schemas/Demand'
            employees:
              type: array
              description: Group of employees available to be planned in the planning period defined by the demand.
              items:
                $ref: '#/components/schemas/Employee'
            statutes:
              type: array
              description: Statute definitions used by employees.
              items:
                $ref: '#/components/schemas/Statute'
            assignments:
              type: array
              description: Pre made assignments that the solver should take into account
              items:
                $ref: '#/components/schemas/ShiftAssignment'

    FairnessBucket:
      type: object
      required:
        - employees
        - shifts
        - period
      properties:
        employees:
          type: array
          description: Employees that need to be distributed fairly
          items:
            type: string
        shifts:
          type: array
          description: Shifts that need to be distributed fairly
          items:
            type: string
        period:
          $ref: '#/components/schemas/PlanningPeriod'


    ShiftFillRequest:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolveJob'
        - type: object
          required:
            - shifts
            - employees
            - contracts
          properties:
            shifts:
              type: array
              description: Pre-defined shifts that need to be filled in.
              items:
                $ref: '#/components/schemas/Shift'
            contracts:
              type: array
              description: Contract definitions used by employees.
              items:
                $ref: '#/components/schemas/Contract'
            fairnessBuckets:
              type: array
              description: Buckets of employees and shifts that require fair distribution of work volume.
              items:
                $ref: '#/components/schemas/FairnessBucket'
            employees:
              type: array
              description: Group of employees available to be planned in the planning period defined by the demand.
              items:
                $ref: '#/components/schemas/FillEmployee'
            requirements:
              type: array
              description: An optional list of shared resource requirements
              items:
                  $ref: '#/components/schemas/ResourceRequirement'
            options:
              $ref: '#/components/schemas/FillOptions'
            weights:
              $ref: '#/components/schemas/FillWeights'



    TaskRequest:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolveJob'
        - type: object
          required:
            - orders
            - resources
          properties:
            resources:
              type: array
              description: Define the available resources
              items:
                oneOf:
                  - $ref: '#/components/schemas/PlannableResource'
                  - $ref: '#/components/schemas/CapacitatedResource'
                discriminator:
                  propertyName: type
                  mapping:
                    plannable: '#/components/schemas/PlannableResource'
                    capacitated: '#/components/schemas/CapacitatedResource'
            orders:
              type: array
              description: Define the orders that need to be assigned to Resources.
              items:
                $ref: '#/components/schemas/Order'
            period:
              $ref: '#/components/schemas/PlanningPeriod'



    CapacityRequest:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolveJob'
        - type: object
          required:
            - demand
            - statutes
          properties:
            demand:
              type: array
              description: Predicted demand for a pred-fined period of time (usually multiple weeks & months).
              items:
                $ref: '#/components/schemas/Demand'
            statutes:
              type: array
              description: Possible Statute definitions used by employees.
              items:
                $ref: '#/components/schemas/Statute'

    CreationRequest:
      allOf: # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolveJob'
        - type: object
          required:
            - demands
            - patterns
          properties:
            demands:
              type: array
              description: demands with either a 'value' or a 'min' and 'max' specifying the demand for a certain skill between two points in time.
              items:
                $ref: '#/components/schemas/CreationDemand'
            patterns:
              type: array
              description: definition of a possible shift for a certain skill. This contains the time intevals during which this shift takes place aswell as the minimum and maximum number of people that can be assigned to this shift.
              items:
                $ref: '#/components/schemas/CreationShiftPattern'
            resourceAvailabilities:
              type: array
              description: definition of a certain resource and how many units of that resouce are available.
              items:
                $ref: '#/components/schemas/CreationResourceAvailability'

    SolveJob:
      type: object
      required:
        - solver
      properties:
        solver:
          $ref: '#/components/schemas/Solver'
        hook:
          type: string
          format: uri
          description: Webhook returns solution status after solving in the form of a POST request to the uri given.


    Error:
      type: object
      properties:
        error:
          type: string
        description:
          type: string

    ErrorCode:
      type: object
      properties:
        errorCode:
          type: string
        explanation:
          type: string
        line:
          type: integer
        column:
          type: integer

    Status:
      type: string
      enum:
        - QUEUED
        - SOLVING
        - SOLVED
        - ERROR
      example: "SOLVING"
      description: The current status of the job. After arriving at the solver engine, it gets `QUEUED` to the right solver, then processed (`SOLVING`) and when finished the status is `SOLVED`.

    Solver:
      type: string
      enum:
        - FILL
        - SHIFT
        - TASK
        - CREATE

    Score:
      description: The score of a solution shows how good this solution is w.r.t all the constraints.
      type: object
      properties:
        hardScore:
          type: integer
          description: The score of the constraints that are hard. This should be 0 in order to be feasible.
        mediumScore:
          type: integer
          description: The score of the constraints that are medium.
        softScore:
          type: integer
          description: The score of the constraints that are soft.
        feasible:
          type: boolean
          description: Feasibility check on hard constraints. Check unresolved parameter if you cannot reach feasibility.

    Statute:
      required:
        - name
      properties:
        name:
          type: string
          example: "FULLTIME"
          description: Unique name for a definition of a statute.
        minShiftLength:
          type: integer
          description: The minimum number of hours in a shift for an employee
        maxShiftLength:
          type: integer
          description: The maximum number of hours in a shift for an employee
        minRestBetweenShifts:
          type: integer
          description: The minimum duration (in hours) of a rest period between two shifts for this employee
        maxConsecutiveWorkDays:
          type: integer
          description: The maximum days consecutive that this employee can be working
        maxHrsPerWeek:
          type: integer
          description: The maximum number of hours this employee can be working in a week
        minHrsPerWeek:
          type: integer
          description: The minimum number of hours this employee should be working in a week
        shiftStart:
          type: number
          description: The earliest this employee can start working (expressed as decimal in 24 hour-format)
        latestShiftStart:
          type: number
          description: The latest this employee can start working (expressed as decimal in 24 hour-format)
        shiftEnd:
          type: number
          description: The latest this employee can work on a day (expressed as decimal in 24 hour-format)
        minHoursMonth:
          type: integer
          description: The minimum hours per month this employee should be working
        maxHoursMonth:
          type: integer
          description: The maximum hours per month this employee should be working
        overTimeThreshold1:
          type: number
          description: The first time threshold for overtime (expressed as decimal in 24 hour-format)
        overTimeRaise1:
          type: number
          description: The raise after the first time threshold for overtime (e.q. 1.2 means a 20% raise per hour)
        overTimeThreshold2:
          type: number
          description: The second time threshold for overtime (expressed as decimal in 24 hour-format)
        overTimeRaise2:
          type: number
          description: The raise after the second time threshold for overtime (e.q. 1.2 means a 20% raise per hour)
        overTimeWeeklyThreshold1:
          type: number
          description:   The number of hours per week after which a "weekly overtime" raise should be given
        overTimeWeeklyRaise1:
          type: number
          description: The weekly overtime raise (e.q. 1.2 means a 20% raise per hour)
        nightlyThreshold1:
          type: number
          description: The time threshold to be considered for a night raise (expressed as decimal in 24 hour-format)
        nightlyRaise:
          type: number
          description: The raise after the first time threshold for overtime (e.q. 1.2 means a 20% raise per hour)


    Contract:
      type: object
      description: Collection of labour agreement rule parameters.
      properties:
        name:
          type: string
          description: Unique name and definition of the contract.
        maxConsecutiveWorkDays:
          type: integer
          description: Maximum number of successive consecutive working days that an employee under this contract is allowed to work.
        maxShiftsDay:
          type: integer
          description: Maximum number of shift per day that an employee under this contract is allowed to work.
        minRestBetweenShiftsSameDay:
          type: integer
          description: Minimum resting time for two successive shifts in the same day.
        minRestBetweenShifts:
          type: integer
          description: Minimum resting time for two successive shifts over different days.
        maxWorkingDays:
          type: integer
          description: Maximum number of total days working in planning period.
        latestShiftStart:
          type: string
          format: time
          description: Latest time at which an employee under this contract can start its shift.
        earliestShiftStart:
          type: string
          format: time
          description: Earliest time at which an employee under this contract can start its shift.
        latestShiftEnd:
          type: string
          format: time
          description: Latest time at which an employee under this contract can finish its shift.
        min:
          type: string
          format: time
          description: Minimum number of hours to work in the planning period.
        max:
          type: string
          format: time
          description: Maximum number of hours to work in the planning period.

    ShiftLocation:
      type: object
      properties:
        latitude:
          description: Latitude in WSG84
          type: number
        longitude:
          description: Longitude in WSG84
          type: number
        address:
          description: Address information or name of location.
          type: string

    Shift:
      type: object
      description: A specific shift that starts at `from` and ends at `to` for which `value` number of employees should be scheduled to according to a skill.
      required:
        - name
        - from
        - to
      properties:
        name:
          description: A unique name for the shift.
          type: string
        from:
          description: Start time of the shift.
          type: string
          format: date-time
        to:
          description: End time of the shift.
          type: string
          format: date-time
        cost:
          type: number
          description: Financial cost related to this shift. Will be minimised when overconstrained.
        value:
          description: Actual number of employees that should be assigned to this shift
          type: number
        priority:
          description: Forces a priority constraint on this shift with 1 being highest priority and 10 being the lowest.
          type: number
          minimum: 1
        location:
          $ref: '#/components/schemas/ShiftLocation'
        skills:
          type: array
          description: Skill requirement definition that should match with skills from Employee. All are required
          items:
            $ref: '#/components/schemas/SkillRequirement'
        employees:
          type: array
          description: List of planned employees. Or can be used to pre-plan.
          items:
            type: string
            description: Employee name
        locked:
          type: array
          description: List of locked employees. Should be equal size as `employees` and maximum `value`.
          items:
            type: boolean
            description: Employee name
        critical:
          type: boolean
          description: Critical shift. These should be assigned first. Similar to `shift.cost`
        blacklist:
          type: array
          description: List of employees that cannot be used for this shift.
          items:
            type: string
            description: Employee name.

    Skill:
      type: object
      properties:
        name:
          description: Skill name. Should match skill name of employee.
          type: string
        expiry:
          description: Date on which the skill expires.
          type: string
          format: date
        weight:
          description: Weight of skill when matching. The higher, the more impartant the skill is to be assigned to someone with that skill.
          minimum: 1
          maximum: 10
          type: integer


    SkillRequirement:
      type: object
      required:
        - name
      properties:
        name:
          description: Required Skill name. Should match skill name of employee.
          type: string
        weight:
          description: Weight of skill when matching. The higher, the more impartant the skill is to be assigned to someone with that skill.
          maximum: 10
          type: integer
        hard:
          description: Whether the skill matching should be seen as a hard constraint or not.
          type: boolean



    FillOptions:
      type: object
      properties:
        hardAvailability:
          type: boolean
          description: If availabilty constraint should be hard or built-in (super hard)
          example: true
        hardSkill:
          type: boolean
          description: If skill constraint should be hard or built-in (super hard)
          example: true
        hardBlacklist:
          type: boolean
          description: If blacklist constraint should be hard or built-in (super hard)
          example: true
        full:
          type: boolean
          description: All shifts should be assigned (full solver). Or try to fill most (not full solver)
          example: true


    FillWeights:
      type: object
      properties:
        unassigned:
          type: string
          description: Weight of having unassigned assignments (hard or medium)
          example: "1medium"
        maxWorkingDays:	 
          description:	An employee should not work more than contract.maxWorkingDays days in the planning horizon.
          type: string
          example: "1hard"        
        maxHours:	 
          description:	An employee should not work more than contract.max hours in the planning horizon.
          type: string
          example: "1hard"          
        minHours:	 
          description:	An employee should not work less than contract.min hours in the planning horizon. Please ensure minimum feasibility over the whole workforce.
          type: string
          example: "1hard"          
        shiftStart:	 
          description:	Earliest time contract.earliestShiftStart in a day when an employee is allowed to work
          type: string
          example: "1hard"          
        latestShiftStart: 
          description:	Earliest time contract.latestShiftStart in a day when an employee is allowed to start work
          type: string
          example: "1hard"          
        shiftEnd:	 
          description:	Latest time contract.latestShiftEnd in a day when an employee is allowed to end work
          type: string
          example: "1hard"          
        maxShift:	 
          description:	Maximum time contract.maxShiftLength that an employee is allowed to work
          type: string
          example: "1hard"          
        dayOfWeek:	 
          description:	Restricts employee availability based on days in the week that
          type: string
          example: "1hard"          
        minShift:	 
          description:	Minimum time contract.maxShiftLength that an employee is allowed to work
          type: string
          example: "1hard"          
        sameDay:	 
          description:	Maximum number of shifts that an employee is allowed to work
          type: string
          example: "1hard"          
        sameDayMinRest:	
          description:	Minimum resting period between two shifts on the same day
          type: string
          example: "1hard"          
        availability:	
          description:	Date-time range of employee's availability
          type: string
          example: "1hard"          
        locked:		
          description:	Take into account assignments that are fixed during the solve
          type: string
          example: "1000hard"          
        maxConsecutive:	
          description:	No more than contract.maxConsecutiveWorkDays consecutive shifts.
          type: string
          example: "1hard"          
        minRest:		 
          description:	Minimum resting between two shifts (irrespective of shifts)
          type: string
          example: "1hard"          
        concurrent:	
          description:	An employee cannot have two assignments on the same time. (This should never happen)
          type: string
          example: "1000hard"          
        requirements:	
          description:	Multiple shifts can have a shared requirement for a skill
          type: string
          example: "1hard"       
        skills:   	
          description:	Assign employees to match according to their skills and the required skills for a shift
          type: string
          example: "1hard"          
        distance:	
          description:	Travel from home to shift location
          type: string
          example: "1soft"          
        priority:	 
          description:	Shift Priorities
          type: string
          example: "1soft"          
        pref:	        
          description:	A preference for a certain shift assignment for an employee
          type: string
          example: "1medium"          
        costs:	        
          description:	Some shifts incur a higher cost when they are assigned to (opposite of priority)
          type: string
          example: "1soft"          
        wages:	        
          description:	Hourly wage cost per employee influences choice of employee
          type: string
          example: "1soft"          
        softSkills:	 
          description:	Assign employees to match according to their skills and the required skills for a shift (soft rule)
          type: string
          example: "1soft"          
        criticalSkills:	 
          description:	Prefer assigning critical shifts first
          type: string
          example: "1hard"      
        working:
          description: Respect employee working days
          type: string
          example: "1hard"
        blacklist:
          description: Respect the shift's blacklist
          type: string
          example: "1hard"
        efficiency:
          description: Efficiency costs per employee
          type: string
          example: "1soft"
        softSkillsLevel:
          description: Respect employee skill level match
          type: string
          example: "1soft"


    PeriodRule:
      type: object
      properties:
        period:
          $ref: '#/components/schemas/PlanningPeriod'
        maxWorkingDays:
          type: integer
          description: Maximum number of total days working in planning period.
        minWorkingDays:
          type: integer
          description: Minimum number of total days working in planning period.
        minWorkingDuration:
          type: string
          example: PT20H
          description: Minimum duration to work in the planning period.
        maxWorkingDuration:
          type: string
          description: Maximum duration (ISO8601) to work in the planning period.
          example: PT40H
        minRestDurationBetweenShiftsSameDay:
          type: string
          description: Minimum duration between two shifts on the same day in this planning period.
          example: PT1H
        minRestDuration:
          type: string
          description: Minimum duration between any two shifts in this planning period.
          example: PT2H



    FillEmployee:
      type: object
      required:
        - name
        - contract
        - skills
      properties:
        name:
          type: string
          description: Unique name/id of employee
        contract:
          type: string
          description: Reference to Contract name
        periodRules:
          type: array
          description: List of period rules that should be applied to this employee.
          items:
            $ref: '#/components/schemas/PeriodRule'
        home:
          $ref: '#/components/schemas/ShiftLocation'
        skills:
          $ref: '#/components/schemas/Skill'
        efficiency:
          type: number
          description: Efficiency rate of employee. 1.0 is normal and default
        hourlyPay:
          type: number
          description: Hourly wage/pay for employee. Total costs are minimised by the optimiser.
        lastRestDate:
          type: string
          format: date
          description: The last date on which the employee had a rest before the planning period.
        canWorkOn:
          type: array
          description: List of days of week on which the employee can work.
          items:
            type: string
            format: date
            description: Day of week
        availability:
          type: array
          description: Available date-time range of employee.
          items:
            $ref: '#/components/schemas/DateTimeWindow'
        preference:
          type: array
          description: Preference towards certain shifts.
          items:
            type: string
            description: Shift name that should be preferred.



    Employee:
      type: object
      required:
        - name
        - statute
        - skill
      properties:
        name:
          type: string
          description: Unique name/id of employee
        statute:
          type: string
          description: Reference to Statute name
        skill:
          type: string
          description: Skill name owned by employee
        efficiency:
          type: number
          description: Efficiency rate of employee. 1.0 is normal and default
        hourlyPay:
          type: number
          description: Hourly wage/pay for employee. Total costs are minimised by the optimiser.
        lastRestDate:
          type: string
          format: date
          description: The last date on which the employee had a rest before the planning period.


    DateTimeWindow:
      type: object
      description: Date time window
      required:
        - from
        - to
      properties:
        from:
          type: string
          format: date-time
          description: From datetime
          example: "2022-01-01T22:00:00"
        to:
          type: string
          format: date-time
          description: To datetime
          example: "2022-01-03T06:00:00"

    Demand:
      type: object
      description: Preferred demand for a certain skill and for a specific block during the day.
      required:
        - shift
        - skill
        - prefDemand
      properties:
        shift:
          type: object
          description: Shift definition
          properties:
            index:
              type: number
              description: Index time of shift block in day. (usually 0 - 23 for 1h blocks per day)
            date:
              type: string
              format: date
              description: Shift blok date.
        skill:
          type: string
          description: Skill type definition
        prefDemand:
          type: integer
          description: The number of employees of that skill to be present.

    ShiftDemand:
      type: object
      description: Preferred demand for a certain skill and for a specific block during the day.
      required:
        - from
        - to
        - skill
        - demand
      properties:
        from:
          type: string
          format: date-time
          description: Starting time of demand
          example: "2021-12-01T08:00:00"
        to:
          type: string
          format: date-time
          description: Starting time of demand
          example: "2021-12-01T16:00:00"
        skill:
          type: string
          description: Skill type definition
        prefDemand:
          type: integer
          description: The number of employees of that skill to be present.
          example: 1

    ResourceRequirement:
      type: object
      description: A shared resource requirement
      properties:
        shifts:
          type: array
          description: a list of shiftnames this requirement applies to
          items:
            type: string
            example: "shift"
            description: shift name
        skill:
          type: string
          description: the skill this requirement applies to
          example: technician
        value:
          type: integer
          description: the required number of shared resources with this skill
          example: 2



    TaskResourceRequirement:
      type: object
      description: A a combination of resource requirements grouped per resource.
      additionalProperties:
        type: array
        items:
          $ref: '#/components/schemas/TaskResourceRequirementDetail'


    TaskResourceRequirementDetail:
      type: object
      properties:
        value:
          type: integer
          example: 1
          description: The number of requirements.
        skills:
          type: array
          description: The required skills that should be matched by the assigned Resource.
          items:
            type: string
            description: Skill name
            example: "technician"
        allowed:
          type: array
          description: The allowed resources that can do this job.
          items:
            type: string
            example: "resource 0"
            description: Resource name

    Order:
      type: object
      description: An order to be planned. Can hold multiple tasks.
      properties:
        name:
          type: string
          description: unique name identifier
          example: "order 0"
        duration:
          type: string
          description: duration of an order (ISO8601 Duration)
          example: "PT1M"
          pattern: '^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d+[HMS])(\d+H)?(\d+M)?(\d+S)?)?$'
        priority:
          type: integer
          example: 10
          description: level of importance of scheduling this as soon as possible (1-1000)
        tasks:
          type: array
          items:
            $ref: '#/components/schemas/Task'
        resourceRequirements:
          $ref: '#/components/schemas/TaskResourceRequirement'

    Task:
      type: object
      description: Task within an order
      properties:
        name:
          type: string
          description: unique name identifier
          example: "task 0"
        duration:
          type: string
          example: PT15M
          pattern: '^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d+[HMS])(\d+H)?(\d+M)?(\d+S)?)?$'
          description: duration of a task (ISO8601 Duration)
        availability:
          type: array
          description: Available date-time range for a resource.
          items:
            $ref: '#/components/schemas/DateTimeWindow'
        resourceRequirements:
          $ref: '#/components/schemas/TaskResourceRequirement'

    Resource:
      type: object
      description: A resource definition
      required:
        - name
        - type
      properties:
        name:
          type: string
          description: unique name identifier for resource
          example: "resourceType 0"
        type:
          $ref: '#/components/schemas/ResourceType'
        availability:
          type: array
          description: Available date-time range for a resource.
          items:
            $ref: '#/components/schemas/DateTimeWindow'

    ResourceType:
      type: string
      description: Resource type, plannable or capacitated.
      enum:
        - plannable
        - capacitated


    PlannableResource:
      allOf: # Combines the Resource and the inline model
        - $ref: '#/components/schemas/Resource'
        - type: object
          properties:
            availability:
              type: array
              description: Available date-time range for a resource.
              items:
                $ref: '#/components/schemas/DateTimeWindow'
            supply:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                    description: unique identifier for resource item
                    example: "named resource 0"
                  skills:
                    type: array
                    items:
                      type: string
                      example: "A"
                    description: list of skills


    CapacitatedResource:
      allOf:
        - $ref: '#/components/schemas/Resource'
        - type: object
          properties:
            supply:
              type: integer
              description: The number of resources necessary.
              example: 1
            availability:
              type: array
              description: Available date-time range for a resource.
              items:
                $ref: '#/components/schemas/DateTimeWindow'


    CreationDemand:
      type: object
      description: A demand for a certain skill during a certain time interval used by the creation solver.
      required:
        - from
        - to
        - skill
      properties:
        from:
          type: string
          format: date-time
          description: The date and time when this demand interval starts.
        to:
          type: string
          format: date-time
          description: The date and time when this demand interval ends.
        skill:
          type: string
          description: The skill for which this demand is defined.
        demand:
          type: integer
          description: The number of people needed for this shift during this time interval for this skill (only applicable to fixed mode).
        min:
          type: integer
          description: The total amount of minutes that need to have been worked by the end of this interval for this skill (only applicable to flexible mode).
        max:
          type: integer
          description: The total maximum amount of minutes of work that is available at the start of this interval (only applicable to flexible mode).

    CreationShiftPattern:
      type: object
      description: A definition of a schedulable shift for the creation solver.
      required:
        - name
        - definition
        - skill
        - min
        - max
      properties:
        name:
          type: string
          description: A unique name for this shift pattern.
        definition:
          type: array
          items:
            $ref: '#/components/schemas/CreationDatePattern'
          description: The different time intervals for this shift.
        skill:
          type: string
          description: The skill linked to this shift pattern.
        min:
          type: integer
          description: The minimum amount of people that will be assigned to this shift.
        max:
          type: integer
          description: The maximum amount of people that will be assigned to this shift.
        resourceRequirements:
          type: array
          items:
            $ref: '#/components/schemas/CreationResourceRequirement'
          description: The required resources needed for each person assigned to this shift.

    PlanningPeriod:
      type: object
      description: The planning period
      required:
        - from
        - to
      properties:
        from:
          type: string
          format: date-time
          description: the starting date-time (ISO 8601 format) for the planning period
          example: "2022-01-01T08:00:00"
        to:
          type: string
          format: date-time
          description: the end date-time (ISO 8601 format) for the planning period (inclusive)
          example: "2022-01-05T17:00:00"

    CreationDatePattern:
      type: object
      description: A pattern definition denoting the time interval(s) for a certain shift.
      required:
        - from
        - to
      properties:
        from:
          type: string
          format: date-time
          description: The date and time when this interval starts.
        to:
          type: string
          format: date-time
          description: The date and time when this interval ends.
        breaks:
          type: array
          items:
            $ref: '#/components/schemas/CreationBreak'
          description: The breaks during this shift.

    CreationBreak:
      type: object
      description: A break is a time interval assigned to a date pattern of a shift during which no work is done.
      required:
        - start
        - end
      properties:
        start:
          type: string
          format: date-time
          description: The start date and time of this break.
        end:
          type: string
          format: date-time
          description: The end date and time of this break.

    CreationResourceRequirement:
      type: object
      description: A required resource used by a certain shift.
      required:
        - resourceName
        - value
      properties:
        resourceName:
          type: string
          description: The name of the required resource.
        value:
          type: integer
          description: How many units of this resource type is required for this shift.

    CreationResourceAvailability:
      type: object
      description: A limited availbale resource that can be used by certain shifts.
      required:
        - resourceName
        - max
      properties:
        resourceName:
          type: string
          description: The unique name of the resource.
        max:
          type: integer
          description: The maximum amount of units of this resource that can be used simultaneously.

    JobId:
      type: string
      format: uuid
      description: Job ID


    SolutionJob:
      type: object
      properties:
        id:
          $ref: '#/components/schemas/JobId'
        solver:
          $ref: '#/components/schemas/Solver'
        status:
          $ref: '#/components/schemas/Status'
        score:
          $ref: '#/components/schemas/Score'



    ShiftSolution:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolutionJob'
        - type: object
          properties:
            solution:
              type: object
              additionalProperties:
                type: array
                items:
                  $ref: '#/components/schemas/BlockAssignment'


    TaskSolution:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolutionJob'
        - type: object
          properties:
            solution:
              type: array
              items:
                  $ref: '#/components/schemas/TaskAssignment'


    CapacitySolution:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolutionJob'
        - type: object
          properties:
            solution:
              type: object
              additionalProperties:
                type: array
                items:
                  $ref: '#/components/schemas/WeekAssignment'


    FillSolution:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolutionJob'
        - type: object
          properties:
            solution:
              type: array
              items:
                $ref: '#/components/schemas/FillAssignment'


    CreateSolution:
      allOf:     # Combines the SolveJob and the inline model
        - $ref: '#/components/schemas/SolutionJob'
        - type: object
          properties:
            solution:
              type: array
              items:
                $ref: '#/components/schemas/FillAssignment'



    ShiftAssignment:
      type: object
      properties:
        date:
          type: string
          format: date
          description: Date of the assignment
        employee:
          type: string
          description: Employee name
        skill:
          type: string
          description: Skill name
        startDateTime:
          type: string
          format: date-time
          description: Date time of the start of the assignment
        endDateTime:
          type: string
          format: date-time
          description: Date time of the start of the assignment
        locked:
          type: boolean
          description: Date time of the start of the assignment

    BlockAssignment:
      type: object
      properties:
        date:
          type: string
          format: date
          description: Date of the assignment
        index:
          type: integer
          description: Index number of the block

    TaskAssignment:
      type: object
      properties:
        order:
          type: string
          description: order name
        task:
          type: string
          description: task name
        from:
          type: string
          format: date-time
          description: start time of the order/task
        to:
          type: string
          format: date-time
          description: end time of the order/task
        capacitated:
          type: object
          description: the combination of capacitated resources used during excution of this order/task, grouped per type. 
          additionalProperties:
            type: array
            items:
              type: integer
              description: number of capacitated resources of this type used.
        plannable:
          type: object
          description: the combination of plannable resources used during excution of this order/task, grouped per type. 
          additionalProperties:
            type: array
            items:
              type: string
              description: name of the capacitated resources of this type used.



    WeekAssignment:
      type: object
      properties:
        index:
          type: integer
          description: Index number of the week
        statute:
          type: string
          description: Statute type definition
        totals:
          type: integer
          description: Total number of statute employees necessary

    FillAssignment:
      type: object
      properties:
        shift:
          type: string
          description: Shift
        employee:
          type: string
          description: Employee
        from:
          type: string
          format: date-time
        to:
          type: string
          format: date-time
        skills:
          type: array
          items:
            type: string
            description: skill



    Stats:
      type: object
      properties:
        id:
          type: string
          format: uuid
          example: d290f1ee-6c54-4b01-90e6-d701748f0851
        goals:
          type: array
          description: List of unresolved goals.
          items:
            type: object
            properties:
              goal:
                type: string
                description: Goal name
              weight:
                type: integer
                description: Weight total for goal.
              conflicts:
                type: array
                items:
                  type: object
                  properties:
                    weight:
                      type: integer
                      description: Specific weight for unresolved goal reasons.
                    reasons:
                      type: array
                      items:
                        type: string



    StatusJob:
      type: object
      properties:
        id:
          $ref: '#/components/schemas/JobId'
        solver:
          type: string
          description: Solver type
        status:
          $ref: '#/components/schemas/Status'

  securitySchemes:

    ApiKey:
      type: apiKey
      in: header
      name: Authorization

  responses:
    NotFound:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    WrongFormat:
      description: Wrong format
      content:
        application/json:
          schema:
            type: object
            properties:
              errors:
                type: array
                items:
                  $ref: '#/components/schemas/ErrorCode'



